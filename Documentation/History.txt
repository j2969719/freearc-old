Версия 0.20 была переписана с нуля с целью достижения следующих целей:
- надёжная обработка ошибок
- разбиение сложных задач на отдельные взаимодействующие треды
- тотальное комментирование исходников на русском языке
- экономное потребление памяти
- увеличение гибкости работы программы для создания томов, storing'а если
    сжатие не удалось, мультипроцессорности и т.д.
- изменение структуры архива и каталога файлов
- создание возможности для добавления шифрования, восстановления данных,
    хранения поколений файлов, соединения алгоритмов сжатия и т.д.

0.20  15.01.05  Hugs-совместимая версия без сжатия
0.21   5.02.05  PPMD, LZMA, LZP; -m1..-m6x, -t, -kb, CRC, восстановление времени/даты
0.22  19.02.05  GRZip, BCJ-x86, -js, сложный декодер -m, full RE in filenames, последняя версия для GHC 6.2.1
0.23  26.04.05  GHC 6.4, FAR plugin, -tl/-tk, arc.ini, %FREEARC, -cfg-, -o, -y, русские имена, экономный read-ahead, HEADER BLOCK
0.24  16.12.05  Compression Library, Extractor, SFX; y/c/cw/k/s/-z/-k/-sfx; --Limit*Mem; Unicode, >4gb, 300 bytes/file
0.25   1.11.06  lzma 4.43, smart update of solid blocks

0.30  15.11.06  dict, ppmonstr; --display, --logfile
0.31  18.11.06  новый LZP; новый парсер -m: m1x..m7, -m4b/3t, dict+lzp+ppmd/pmm, lzp+lzma; [Compression methods], --print-config
0.32  06.12.06  Первая публичная версия (прорекламированная с dict)
0.33  10.12.06  -dsgecpn; написан раздел документации "Конфиг-файл arc.ini"
0.35  09.01.07  REP: заменил lzp в сжатии бинарных файлов
0.36  22.02.07  r/rr, -ac/-ao, m[f], -d[f], -t/-pt, -w, -lc/-ld и куча мелких усовершенствований
0.40  ??        MM, tornado, delta, lzma -mt, ext.compressors, tempfile; encryption, unix version, -sc/far/tc, full eng. docs, ^Break, warn/error/fail->logfile+stderr+exitCode, -cfg/-env, -n/-ta/../-sl/-sm


to do:
  сохранение/восстановление атрибутов файлов, отбор по ним (а что делать в Unix'е?)
  комментарии к файлам, files.bbs
  оптимизация архива - копирование с "-m0 --recompress", затем с нужными опциями сжатия и сортировкой
    файлов внутри архива. аналогично - добавление в архив с оптимизацией
  Cmdline.hs - обрабатывать сначала общий конфиг-файл, затем личный, затем переменную среды FREEARC
    и наконец командную строку. Обрабатывать опции в порядке их приоритета (от общих к частным),
    в пределах одного приоритета - в порядке появления в командной строке
  ByteStream to-do
  "arc a ..\{} -m{3 4 5}"
  опция "сортировать список файлов в порядке их указания в командной строке/листфайлах"
  Intel-зависимости:
    ByteStream
    LZP от Димы Шкарина - 32-bit only!
    REP
Улучшение сжатия:
  Фильтры: распаковка jpeg, deflate; exe-disasm
  вместо -ms: lzp - если сжатие как минимум на 10%, то дальше сжимать обычным алгоритмом, иначе - storing
  exe-фильтр зря тратит время (и ухудшает сжатие) на неисполняемых файлах
  bcj2: анализировать статистику по собранным смещениям прежде чем применять к ним вычитание
  bcj: поблочный (64кб) вывод с доп. байтом-флагом - применять ли bcj при распаковке?
    можно собрать все смещения из команд E8/E9 в конце блока
  lzp: разбивать блок на маленькие блоки по 64к и решать, упаковывать или нет, для каждого из них в отдельности
  perl - похоже на неоптимальный порядок сортировки
  импортировать новый ppmd ?
  lzma: _flushPos - скидывать данные и обновлять статистику каждые 256к, а не 8 мб :)
  dict: ускорить сжатие, улучшить работу с bwt/ppmd (использовать только ориг. символы или модифицированный 16-битный bwt/ppmd) и использовать в -m3
        оптимизирующий проход может решить проблему сжатия бинарных файлов
  tta: signature, non-diff modes
    compression parameters in header of *each* block (что позволит изменять их от блока к блоку)
    rice & arith encoding, не сбрасывать таблицы кодирования перед следующим блоком
  dict preprocessor на словарях (ааа, ааб...) - analyze and abandon transformation?
Улучшение менеджмента сжатия:
  сбор статистики о файлах с незнакомыми расширениями для выбора алгоритма сжатия
    запись этой информации в конфиг-файл пользователя
  Поддержка BCJ2-подобных алгоритмов (улучшит LZP, REP, DICT, DELTA)
  Улучшение алгоритма выбора размера солид-блока с учётом больших файлов на границе
    условия >=0.5bs, <=1.5bs - сделать их строгими для и для GroupBySize, и для GroupByBlockSize
  при разбиении на solid-блоки учитывать "близость" файлов по типу/подтипу(C,Haskell,HTML...)/расширению/трём первым буквам имени/пути
  mNxb/mNxt - использовать разные настройки lzma для текстов и не-текстов?
  отбор по группам и подгруппам в ком. строке - "arc a a $text -x$$haskell"
  рефакторинг comressionLib - отделить тайминг от чистой (де)компрессии
    ввести универсальный callback, используемый для readN/writeN/*time/*ui
    ввести универсальную функцию для запроса/установки параметров метода
  ДИЗАЙН ПОТОКА СЖАТИЯ:
    huftest              проверка распределения вероятностей символов
      copy                 блоки с равномерным распределением - просто скопировать
      multimedia           мультимедийные данные сжать спец-компрессорами
      lzp                  блоки с текстовым распределением обработать lzp
        lzma/ppmd?           служ. информация
        dict                 словарный алгоритм
          lzma/ppmd?           словарь
          ppmd                 текст
      exe-filter           блоки с нетекстовым распределением обработать BCJ2 (E8/E9)
        copy                 служ. информация
        diff-filter          обнаружение табличных данных
          copy (?)             служ. информация
          lzp                  lzp-препроцессинг
            lzma/ppmd?           служ. информация
            lzma                 основные данные
ошибки:
  согласовать при распаковке uiCompressedBytes (count_cbytes) и остальные ui... в другом треде
  восстановление летних/зимних дат (распаковка зимой летнего архива) приводит к сдвигу на час (в том числе в Extractor)
  -s- не работает при большом кол-ве файлов
проблемы:
  wfindfirst на пустых дисках
  w95 file api support
  по умолчанию не сжимать hidden/system файлы (только с опцией -??)
  -r0: "arc a archive dir dir\*.* -r0"
     r0: Enable recurse subdirectories only for wildcard names
мелкие недоделки:
  Улучшить использование hSetFileSize
  убивать decompression thread при сбоях в основных тредах?
  -ag - преобразовывать rar'овский формат в наш внутренний
  UTF8Z ускорить: (de)serialization, joinDirFilename
  Команда 'm'
    добавить warning при ошибке удаления файла?
    выводить имена всех удаляемых файлов при -i2?
    сортировка каталогов перед удалением?
  ByteStream problems:
    Compressor==[String] - плохо, поскольку он является экземпляром BufferData (восстановить write в archiveWriteDir)
    поддержка String в дичайшем виде; нужно использовать UTF8Z.hs
    отделить типы данных, используемые в программе, от кодирования, используемого в Directory
    pos::Addr#, CPS style for readUnchecked (10.43->8.98 (String w/o reverse))


сделано в 0.24:
  Исправлены ошибки в моей реализации GRZip и LZMA ("DecoderError = 1" при "-m0=exe,3x")
  Compression Library, Extractor, SFX; команда "s" и опция "-sfx" (механизм разрешения коллизий между опциями)
  Улучшена обработка ^Break; исключения, возбуждённые в процессах, достигают основной порграммы
  Дескриптор блока пополнился CRC данных и самого дескриптора, разделены упакованный и исходный размеры данных
  Поддерживается распаковка каталога архива и других служебных блоков; -s=arj/zip/cab не сжимает их, если явно не указана опция -dm
  Комментарий к архиву, опция "-z", команды "c"/"cw"
  Закрытие архива от изменений, опция "-k", команды "k" и "y"
  Не перепаковываются solid-блоки, передаваемые из архива в архив без изменений
  При выводе скорости архивации не учитываются данные, которые уже были упакованы
  arc a a -m3 -ds  -  файлы разделяются по типу даже когда отключена сортировка
  Для grzip/lzp - солид-блок не больше блока сжатия
  Размер dictionary - не больше размера упаковываемых данных
  Поддержка комплексных критериев для создания солид-блоков, например "-se100f10mb"
  Потребление памяти ограничено 3/4 её физического объёма
  Опции --LimitCompMem/--LimitDecompMem ограничивают использование памяти при упаковке/распаковке
  -md - эмулируется поведение rar, заодно добавлено -ms
  При разбивке на солид-блоки учитываются границы старых солид-блоков (16mb -> 16..32 mb, 100 files -> 100..200 files)
  В lzma:limitMem округлять словарь вниз до степени двойки (иначе памяти будет использоваться больше)
  исправлено в 6.4.1:
    awaitRequests [после тестирования по "-t"] после сжатия, использовавшего 180 мб озу
    использование нескольких алгоритмов сжатия, типа -m0=exe,lzp,m4x
  fileCopyBytes по 64k
  PPMD: внесены изменения в makefile для работы с 6.4.1 (-O3/-O1 вместо -O2)
  файлы и архивы >4GB
  Unicode: filenames, вывод на экран, разбор ком. строки, listfiles
  потребление памяти уменьшено в 3-4 раза (PackedStrings, packext, отменён -funbox-strict-fields,
    нужные поля сделаны строгими и нужные UNPACKED, return $! length, performGC)
  UTF8Z packed strings с case-insensitive sortOn' (сортировкой БЕЗ Shwarznegian transform)
  "RTS -c" теперь используется по умолчанию
  Исправлена ошибка - CTime==-1 (1786-й год) больше не приводит к вылету "arc l 250_000"
  Отключен отчёт об ошибке чтения каталога "System Volume Information"
ARC 0.24 (16.12.2005)
  Команда "a -t" теперь не выводит повторно информацию об архиве
  Перепаковка архива (--recompress) - не интересоваться старыми солид-блоками в splitBy и is_whole
  Не перепаковывать при команде "y", если нет добавления/удаления файлов или --recompress/--optimize
  Исправлено: каталоги НЕ перемещались в начало списка - см. архив в erl5.1.2
  Обновление архивов, содержащих файлы, сжатые "fake" и "crc":
    splitByType: для файлов, сархивированных фейк-алгоритмами, определять компрессор как старый
    data_compressor: то же самое, а для каталогов - m0
  --nodata, --crconly, -m0, fiIsDir ==> не разбивать файлы этих типов на отдельные солид-блоки
  -m0 - при распаковке файла делать сразу Seek к его позиции
  частичная распаковка солид-блоков в PPMD (в остальных алгоритмах уже работает)
  getCPUTime делать в Си перед и после вызова упаковки/распаковки
  Быстрое обновление солид-архивов - перепаковывается только один блок!
    fixed: синдром 1мб+64мб+64мб (вставка нового файла может вызывать каскадную перепаковку всех последующих солид-блоков)
  Исправлены ошибки: lzp:8mb+ppmd => -s8m
                     lzp - не сжимался последний прочитанный блок
                     testing time при -m*p - чистое время гораздо меньше полного (?!)
  -m3t: ppmd->grzip (вдвое быстрее распаковка, упаковка быстрее на 10-20%, сжатие хуже на 2%)
  сортировка по умолчанию gen -> gepn
  unsafe->safe for file operations (для реальной многотредовости)
  отключен exe-фильтр в -m*p режимах для *.a, o, obj, lib
  --cache16m если хватает памяти, --cache256k иначе; --cache-
    увеличение read-ahead buffer для block-processing алгоритмов (grzip/lzp) до 2*blocksize
  Fixed: -mNxp, like -mNp, should include exe preprocessing
  -mNxp - add lzp preprocessing for text files
    30% - for any N
    70% - 5x - 1.261 kb, 8m:l32:h15,5x - 1.271 kb.
    5x->l64 - безопасно, но не так быстро.
    альтернатива - l32:60% для всех, начиная с -m3x
    l64 - лучше для exe-шников, 5x, и тех файлов, которые от lzp только проиграют
      хуже только для быстрого сжатия "хороших" текстов (ghc-src)
    m3/m4 - l32, отказ при маленьком числе длинных строк
    m5    - l64 (128), отказ при >85%
      lzp:63%/23% для lzma и grzip preprocessing-а!! (41% - крошечный выигрыш с lzp)
        при большей степени сжатия и не-x-овых алгоритмах есть смысл увеличивать эту границу
        20-60% lzp-сжатия дают 10-30% уменьшения времени -m4x; 4x сжатие даёт ускорение почти в 3 раза
        18%: распаковка в 1.5-2-2.5 раза медленней (h13/h15/h18), упаковка в 2-4 раза быстрее (-m3x/-m4x)
        erlang: 70% и при этом улучшение сжатия на 0.4% в -m3x
    dict+m5px: lzp 83% (ghc) - выигрыш всего 0.3% (speed +10%),
               56% (javadoc) - выигрыш 3%, 69% => 1.5% (speed +20%). lzp:h13 - не проблема
  -m3tr => ppmd:9:48m
  Импортирован lzma 4.43!!!
    -m2 = -m2x+m2t, -m2p = -m2px+m2pt. старый -m2 переименован в -m2r
    -m2x => "lzma:2m:fast:6:mc1", -m3x => dict=4mb
    4x/mc16: size+1%, time -20%(exe) -5%(text)
    3tp: lzp:4mb:l55:h15,ppmd:7:40mb
    4tp: lzp:6mb:l85:h18,ppmd:10:84mb
    5tp: lzp:8mb:l145:h20,ppmd:16:176mb
  Не помогло: createPinnedByteArray# в UTF8Z должен значительно уменьшить расход памяти
ARC 0.25 (1.11.2006)
  --LimitCompMem=75%
  Печатать "using memory ..." в CUI
  --display: опция для подавления вывода отдельных строк в CUI
  --logfile: опция для записи информации CUI в лог-файл
  -m3p отныне использует grzip:m1, вариант с ppmd вызывается опцией -m3pr
  Реализован dict!!!
    dict:75% + lzp:75% + lzma
    dict:16m+... -> bs=16m
  logfile - теперь открывается не в эксклюзивном режиме, слава богу
  Отключена сортировка файлов при "-m1"
  External compressors: ppmonstr
  Dict: добавлено гибкое конфигурирование, втч. настройки :p и :f
  Максимальное количество последовательно используемых алгоритмов сжатия увеличено с 4 до 8
  В качестве препроцессора для ppmonstr на бинарных файлах используется lzp:256:95%
  Сообщения об ошибках - в логфайл!
ARC 0.30 (15.11.2006)
  Импортирован новый LZP Димы Шкарина
  lzp:64m:512:d4m:32  -  искать совпадения длины>=512 в первых 8 мб и длины>=32 в оставшихся 64-4 мб!
  3p..5p: добавлен lzp-препроцессинг для бинарных файлов:
      5p: lzp:64m:512:h22:d16m:s32:85% + lzma
      4p: lzp:32m:512:h20:d08m:s32:85% + lzma
      3p: lzp:16m:256:h18:d04m:s20:85% + lzma
  В качестве препроцессора для ppmonstr на бинарных файлах используется lzp:256:d1m:s32:h22:85%
  dict on "doc" & "help": изменить "cnt/10" на "cnt"
  упрощение выбора метода сжатия:
      arc.ini [Compression methods]
      -m4b/3t
  методы упаковки:
      m1..m9 - ориентированы на быстрое и сильное сжатие
      m1x..m9x - ориентированы на быструю, требующую мало ОЗУ распаковку

      m5  = exe+m5b,  $obj => m5b,  $text => m5t
      m5x = exe+m5xb, $obj => m5xb, $text => m5xt

      m4b = lzp+lzma, m4t = lzp+ppmd
      m6b = lzp+pmm,  m6t = lzp+pmm
      m5xb = lzma, m5xt = dict+lzma
  --print-config
  dev-cpp, msys, cygwin? - сжатие было гораздо хуже в *p режимах из-за повторов exe-файлов
  -m - обрабатывать сразу список всех опций, начинающихся на "-m"
ARC 0.31 (18.11.2006)
  Экспериментальная версия:
      m6 = lzma/pmm, m7 = lzma/pmm:10:r1, m2t += dict, m3b..m5b -= lzp
  Ускорена первая фаза dict (чуть хуже сжатие)
  Окончательная версия (прорекламированная с dict): lzp в m3b и выше, dict в m4t/m2xt и выше
ARC 0.32 (4.12.2006)
  Написан раздел документации "Конфиг-файл arc.ini", описана опция --print-config
  -ds=gepn не идеальна. хорошо бы подтаскивать поближе одинаковые по имени/размеру файлы, но это означает проблемы для обновления солид-архивов
    либо одинаковые по имени _и_ близкие по размеру (разные версии?), либо одинаковые по размеру (переименованный файл?). разумеется, всё это в пределах одного расширения
    от этого выиграют cygnus, dev-cpp, ruby
    файлы до 1 кб полностью игнорируются, до 16 кб - совмещаются только при совпадении имени+размера
  -ds=gecpn: файлы до 128 кб сортировать по gepn, больше - по ges
  -ds=geipn: интеллектуальная сортировка по ges/gepn (одиночные файлы/группы файлов с одинаковым началом имени, типа ssh-*)
  по умолчанию используется -ds=gecpn
  -md8 устанавливает словарь 8 мб (в отличие от rar!)
  lzma: не округлять словарь до степени 2
ARC 0.33 (9.12.2006)
  !!!REP: <=1.25x памяти, очень быстрая упаковка/распаковка, поиск совпадений длиной от 32-512
          заменил lzp в сжатии бинарных файлов
ARC 0.35 (5.01.2007)
  Заменены на registerError вызовы fail, которые могут быть вызваны ошибками пользователя
  Вывод warning'ов в логфайл
  В опцию --display добавлен флаг 'w' для управления выводом warning'ов на экран
  Перенос файлов в архив (команда m[f] и опция -d[f])
  В опцию -ds добавлена буква 'r' для явного задания дополнительного переупорядочения файлов
  -m$iso=5xb, -m5xb/5xt/$iso=ecm+exe+5xb, -m5x/$iso=ecm+exe+5xb
  arc.ini: 5x = 5xb/5xt/$iso=ecm+exe+5xb,  5x$iso = ecm+exe+5xb
  невозможно под Windows: переименовывать архив сразу после создания во временное имя
  Использование уникального временного имени (temparcXX.tmp) в процессе создания архива
  Опция -w
  Fixed: улучшить reorder: ar+ranlib+ar+ranlib -> ar+ar+ranlib+ranlib
  Команды l/v: всегда выводить "listing archive..."
  "arc y archive --nodata --recompress" - удалить сжатые данные из архива, оставив только оглавление
  Переименовывать архив в окончательное имя только при отсутствии ошибок в тестировании по -t
    -kb позволяет оставить сбойный архив
    проверять архив ещё раз после копирования, если -w & -t (?todo: и не проверять перед копированием, если старого архива не существует/можно создать новый архив параллельно со старым)
  Выбирать по архивному атрибуту/очищать его (-ao/-ac)
  archiveReadFooter для быстрого выполнения cw и сигнализации о залоченном архиве
  Защита и восстановление архивов (команды 'r/rr', опция '-rr')!!!
    -pt - режим тестирования архивов _перед_ выполнением операции (0 - нет, 1 - только recovery info, 2 - recovery или full, 3 - recovery и full testing)
      -pt == -pt2. -pt+ == -pt2. -pt- == -pt0. by default -pt1
    parseCmdline - проверять на корректность значение опции/команды 'rr'
    автовыбор размера сектора в зависимости от процента 'rr': 1% -> 2048, 2% -> 1024...
    огромные архивы - в Int не влезут числа, а в память - recovery информация
      если архив слишком большой - увеличить размер сектора и уменьшить количество recovery sectors, чтобы crcs+rec_sectors влезли в physMem/2
      аккуратно работать с производными от arcsize - они могут быть слишком велики
    прочитать sectors без проверки crc и при восстановлении данных архива
      проверять crc восстановленных блоков - это позволит восстанавливать *любые*
        потери до N последовательных секторов и отслеживать ситуацию неуспешного восстановления
    продумать вопросы надёжности при сбоях в конце архива
      последний сектор архива должен отображаться на последний сектор RB
  Исправлена ошибка: -m1 -s- -t не работает
    LZP не должен пытаться сжимать блоки <16 байт :)
    Out<OutEnd теперь проверяется прямо в цикле
  Исправлена ошибка: key_func не содержит варианта для 'c'/'i', что вызывает проблемы при обновлении архивов
  REP: сокращены требования к памяти при распаковке с 2x до 1.125x
  -lc/-ld: синонимы --LimitCompMem/--LimitDecompMem
  Восстановлена совместимость формата архива с ARC 0.35
  Исправлено: сообщение об ошибке BROKEN_ARCHIVE по-разному используется в разных частях программы
  В -m#x режимах словарь lzp уменьшен до размера словаря lzma (и вообще от lzp там толк только на javadoc)
  Размер солид-блока по умолчанию увеличен до 1gb
  Исправлена ошибка в grzip, найденная Jean-Pierre Demailly (LZPBuffer=...+1024)
ARC 0.36 (22.02.2007)
  Файлы, пропускаемые при архивации, исключаются из вычислений индикатора прогресса
  Команда 'y' переименована в 'ch' для совместимости RAR
  Для команд, копирующих архив ("ch s k c rr"), при использовании опций -m../--nodata/--crconly
     автоматически включается опция --recompress
  Команда 'lb' - голый список файлов в архиве
  В опцию --display добавлен флаг 'r' для управления выводом на экран информации о ходе работ по защите архива
     флаг 'f' теперь используется вместо 'r' для вывода информации об общем объёме обработанных файлов
     флаг 'o' для вывода строки о доп. опциях
     флаг 'e' для вывода пустой строки в конце работы
     флаг 'h' для управления выводом на экран номера версии архиватора
     флаг 'n' для нормального вывода обычных сообщений о ходе работы
  -z работает также при распаковке
  !!!TTA для звуковых файлов, включая MMDET
     -s64k для TTA, 1mb for mmdet, -m0 when mmdet failed, тестирование {1,2,5,6,8} каналов
  Настройки MM сжатия перенесены в Compress.hs
  -di = --display, -di+m, -di-=w, -di-- restores default settings
  display explanations for commands too
  lzma 34m->32m: округлять словарь вниз до 32 kb, 48 kb, 64 kb...
     map (\x->(x,(x*23 `div` 2+4)*4 `div` 3)) $ take 10 $ iterate (*2) 3
  проверена работа алгоритмов ограничения памяти при 1.5gb/768mb/...
     выражение (parsePhysMem "50%" - compressionMem) может сбоить при больших значения compressionMem или давать отриц. рез-ты
     compressorGetCompressionMem, getPhysicalMemory могут давать отрицательные результаты при выходе за 2gb
  -m8/-m9 - неправильно срабатывало ограничение памяти из-за переполнения Int
     объём ОЗУ теперь округляется до целого числа мб
  Добавлен Tornado!!! -m1=tor:3, -m2=tor
  MVar oneIOAtTime гарантирует последовательное выполнение I/O операций
     и следовательно отсутствие избыточного количества disk seeks (144->120 сек. для -m1)
  Группа $audio в arc.groups переименована в $wav, $rgb -> $bmp
  Описание внешних упаковщиков (пока без опций) в arc.ini!!!
  MM preprocessor + grzip/lzma for $bmp compression
  TTA, MMDET, MM: offset field
  улучшен entropy analyzer: теперь он предпочитает 1*16 вместо 2*8, и 2*24 вместо 6*8, если оценка сжатия при этом ухудшается не более чем на 5%
  сортировка опций при выводе help
  DICT: поправлена ошибка, приводившая к вылету на больших файлах, многократно включающих посл-ть FF F0
  Документация обновлена - теперь она описывает все возможности программы
  -ms: используется -m0 вместо -m1 для уже сжатых файлов
  added building guide
  Исправлена ошибка: -mlzma/ppmd
  Добавлены описания методов m6p..m9p/q, lzp убран из методов -m#xt
  Настройки MM сжатия перенесены в Compress.hs
  Исправлена ошибка: arc e a -dpdir
  При запросе к пользователю теперь выдаётся help при неправильном ответе
  "-mt" для управления LZMA multithreading (enabled by default)!!!
  Описать external compressors: CCM, ECM, PRECOMP, PackJPG
  Выводить "--" в экранном help
  сортировать строки в [Compression methods] (отдельно встроенные и пользовательские) - # после non-#
  ghc 6.6.1: ^Break заработал!
  Tornado: form.pm
  TTA: disable 24+ bit samples processing
       storing of non-compressible blocks
  $iso,$zip,$jpg groups, #p$iso=..., added more files to $wav/$bmp, $mod group for stm/mod/s3m modules
  Fixed: устранить зависания при выходе (делать exit самому :)
  "tempfile" вставляется между методами сжатия так, чтобы в каждый момент времени
    использовалось не более "-lc" байт памяти! -m6 теперь реально работает!!!
    теперь реально используемая память отображается и в CUI
    "tempfile": не выводить сообщений на экран и упрятать его определение внутрь программы
    вывод "tempfile" в CUI
  wav/bmp/jpg files: -s-
  Fixed: external compressors - проблема если файл не удалось сжать :)
    Если внешний упаковщик отсутствует, то файл будет просто сохранён без сжатия
  Fixed: решить проблему с вычислением чистого времени external сжатия/lzma при -mt+
  Убрано странное ограничение на одновременное использование -d и -ao
  Fixed: -ao -r не видело файлы в подкаталогах
  Done: весь вывод на экран должен идти только через CUI/Error
  особый учёт памяти для dict/dict+lzp (blocksize*2 на оба, blocksize/2 на выходе),
    что позволило наконец-то увеличить автоматически устанавливаемый размер кэша в -m3r/-m4 до 64 мб!
    в limitMemoryUsage теперь проверяется условие mem+NewMem < 1.05*memlimit
  tempfile: теперь вставляется и при распаковке так, чтобы влезть в -ld
  "+RTS -c" возвращено
  Для кэша теперь используется blockSize байтов вместо 2*blockSize
  MM: fixed bug with undefined offset after failed autodetection (failed compression of ruby/*.bmp)
  "--debug" заменено на -di+$#; выводится использование памяти для каждого солид-блока
  "checked read nullPtr 0" в checkingCtrlBreak: не запускать следующий процесс пока предыдущий
    не выведет хотя бы один байт своих результатов. В частности, откладывается запуск процессов,
    находящихся после "tempfile"/external compressors. А это в свою очередь означает, что
    память для упаковки в целом может быть посчитана как maximum от памяти для отдельных алгоритмов
    вместо sum, как это было раньше. Ну а это означает, что теперь мы можем использовать:
  -mx = -m9, -max = -m9p!
  "Memory used..." округлять до мб, freearcLimitDictionary - тоже
  mm+grzip - рассматривать как блочный алгоритм, grzip blocksize = solidblocksize+100
  "-mm" - управление мультимедиа-сжатием: mm-, mmfast, mm=max, mm/mm+ (max/fast autodetection)
  COMPRESSION_METHOD
    Универсальный метод int doit (char *what, int param, void *data, CALLBACK_FUNC *callback)
      what: "compress", "decompress", "setCompressionMem", "limitDictionary"...
      data: данные для операции в формате, зависящем от конкретной выполняемой операции
      param&result: простой числовой параметр, чего достаточно для многих информационных операций
      typedef int CALLBACK_FUNC (char *what, void *data, int size, CALLBACK_FUNC *callback)
        what: "read", "write1", "stat", "time"
    Неиспользуемые параметры устанавливаются в NULL/0. result<0 - код ошибки
  compressionLimitDictionary - не ограничивать после внешних компрессоров в цепочке (precomp/ecm!)
  external: limitMemory: учитывать что память для таких процессов не используется одновременно с другими
     lzma:1m+pmm:64m+lzma:1m => 64mb memory used
  -m2x -= dict, grzip/lzp/tor - уменьшать :h при setDict/setMem
  ^Break - в logfile, ^Break во время -t - стирать временный архив, ^Break при распаковке
      ^Break после начала удаления файлов - сообщать где можно найти temparchive
      bracketCtrlBreak, handleCtrlBreak
      fileCopy (хотя он всё равно не вызывается)
  Упорядочено использование aBUFFER_SIZE, aLARGE_BUFFER_SIZE, aHUGE_BUFFER_SIZE
  Вдвое ускорен -m0, мин. кэш: 4*aBUFFER_SIZE -> 1мб
  Fixed: a -m1 + ch (--recompress недостаточно), учёт decompression times при обновлении архивов
  Отбор файлов по [атрибутам,] имени, размеру и времени модификации (-ta,-tb,-tn,-to,-sl,-sm,[-e],-n)
  Задокументированы параметры алгоритмов сжатия (mm, tta, tor...), внешние алгоритмы
  -m3=-m3r, -m2=lzma:fastest/grzip:m4, -m$bmp=
  автоувеличение размера буферов read-ahead при большом кэше
  -ms = -m$compressed=rep:8mb:128+tor:2:64k, strcasecmp в UTF8Z
  Fixed: exe+rep+lzma - нераспаковка частичных блоков
         arc a a -t -mdict:16m+1xb perlhtm
         arc a a -t -mdict+2xb     help
  Fixed TTA: 24-bit, float 32-bit
  Fixed Tornado: tor:1
  Fixed MM: o1048576 - была забыта инициализация offset и не проверялось offset<=bytes
  Изменена настройка -m2: lzma->tor, -m2r for lzma stuff
  lzma:1m для directory compression
  dict/lzp/grzip/bcj: fixed double "BYTE *In" problem :) and added memory allocation checks
  -ds=gerpn вместо gercpn
  использовать getProcessorsCount для включения многопоточного сжатия только на многопроцессорных машинах
  Бесполезно: dict - использовать коды 0-31 только для первого/второго байта слова, улучшить хеш (137, 219, 317 -> большие числа)
  -m2/-m2x: use BCJ preprocessor only for $exe group  (в результате чего они попадают в отдельную solid-группу :( )
  Table preprocessor!!! ("-m=table")
  -m0=lzma:a=1:d=3424k:fb=264:lc=2:lp0:pb0:mf=bt4  -m0=ppmd:o=4  (a-la 7-zip)
  Encryption!!!
    options "p", "hp", "kf", "op", "okf", "ea"
    -ea=aes,blowfish,serpent,twofish/cfb,ctr; also -ea=aes+twofish/ctr+serpent
    key+checkCode <- Pbkdf2Hmac (password, salt, keySize+2)
    aes-128, blowfish-64, :r=rounds:n=numIterations
    systemRandomData + fortuna PRNG для generateRandomBytes
  -mcd- (-mc-table), -mce- (-mc-exe), -mcl- (-mc-lzp), -mcr- (-mc-rep), -mcz- (-mc-dict)
  -mcc- (-mc-$bmp), -mca- (-mc-$wav), -mct- (-mc-$text)
  Linux-версия!!!
    GetPhysicalMemory, GetProcessorsCount, getThreadCPUTime (todo: gettid/times/getrusage)
    берёт конфиг-файлы из /etc, SFX из /usr/lib or /usr/local/lib, GetExeName
    UTF-8 for filelist/screen/filenames/cmdline encoding, >4gb files support
  Fixed: не мог открыть ini-файлы в "C:\temp\упаковка\Arc.exe a a"  (fileGetBinary + linesCRLF)
  -sc: настройка кодировок filelists, comment files, ini/groups files
     to do: terminal, logfile, filenames in filesystem, program arguments, filenames in archive directory
     to do: -scFILELIST=UTF-8...
  -pt => -tp, -ea => -ae
  Сняты ограничения на количество алгоритмов сжатия+шифрования в цепочке упаковки/распаковки
  Warnings
    печатать количество warnings в конце работы или "All OK" (пока повешено на -di+n)
    код возврата программы: 0 - ok, 1 - warnings, 2 - fatal error, 255 - ^Break
    errors & warnings (включая ошибки от системных функций - создание 0:\a.arc и тому подобное)
      вывод в логфайл и на stderr
  -env=ENVVAR, -env-; -cfg=alternative.ini в командной строке и переменной среды
  Статистика: 288 кб алгоритмы упаковки, 174 кб CompressionLib, 474 кб FreeArc
  исправлены ошибки:
    OemToChar -> OemToCharBuff поскольку коммент-файлы могут содержать \0
    ppmd/pmm:o - увеличивать/уменьшать автоматически при SetCompressionMem
    --append должен задавать быстрое добавление в конец архива
    "arc a a -x*.doc" заодно удаляло doc-файлы из архива :)
    "m" удаляло на диске файлы, которые были переданы из старого архива
    Исправлены проблемы с именами, включающими символы []
    Wildcards с русскими буквами (типа *й*) теперь обрабатываются правильно
    "arc a a @list" + пустая строка в файле "list" - добавляло все файлы в каталоге и подкаталогах
    Опции отбора -n/-sl/-sm/-ta/-tb/-tn/-to - отключать при них автодобавление пустых каталогов
    -sl/-sm - мегабайты ;)))
    "arc t *" when no archives exist
    "-se100f" не работало
  "-lc75p" = "-lc75%"
  Позволено использовать "arc j archive" для слияния всех архивов в текущем каталоге
  Used tta:m1 for -m1$wav, mm:d1+tor:2 for -m1/-m2$bmp
  rep - читать кусками не более 8 мб. сравнить сжатие на delphi и dll.dll в -m6(b)
    dll700: 558,501,826->557,329,150 (171.983.631->171.705.165)
    delphi: 308,633,068->308,632,781 ( 71.672.004-> 71.694.135)
    ghc:    258,373,585->258,374,297 ( 24.869.817-> 24.880.397)
  Для tor:1..4/lzp:h13..15 - отключить сортировку файлов
  доделать tornado/table, table->delta
  FAR plugin: поддержка русских имён файлов и каталогов внутри архива
              архивы с русскими именами создаются, просматриваются и распаковываются
              более полная поддержка возможностей архиватора: move/rr/encryption/-w
  TotalCmd: поддержка русских имён файлов и каталогов внутри архива
  BCJ: filter updated to 4.49 version - 2x faster!
  solid block size = sum(filesize)+512  (для tor желательно добавлять как минимум 256)
  -m1$exe=exe+1xb (+2% compr. -10% speed)
  mm: -d1/2 упрощает и ускоряет детектирование типа файла (64кб 1*8. 3*8, 1*16, 3*16)
      в обычных режимах проверяется не более 512кб/половины файла
      (скорость была 3мб/с, что мало для -m1..-m3)
  -m#p$jpgsolid = precomp+rep:32
  исправлены ошибки:
    "arc a a c:\dir\file" сохраняло в архиве абсолютные пути, а "arc x a" затем извлекало их
    "arc x -dpc:\win2" - не создаёт win2; "arc x -dpc:" - извлекает в корень; "arc x a -dp\"; "arc x a -dpc:\"
    "arc a a \*"; "arc a a c:\*"; "arc a a c:*"
    "arc x a -dp/121"; "arc x a -dp121" при наличии абс. путей в a.arc
  -ep..-ep3
  FAR plugin: 64-bit filesizes (support for archives larger than 4gb)
  Unarc: 'l'/'v' commands with unicode support  (unarc v --noarcext -- a.arc)
  Total Commander: much faster archive open operation
  Fixed -m1 mode in linux (removed huf2 - second huffman tree, incompatible with -fstrict-aliasing)
  Tornado fixed bugs:
    Первый элемент MM таблицы разбит между блоками записи при распаковке
    Сброс match'ей на buf при сдвиге буфера приводил к сбоям, когда эти матчи расширялись на 1 байт назад
    Вставка в хеш строки >256 байт может означать что будут прохешированы мусорные символы взамен
      ещё не прочтённых, если эта строка кончается там, где находятся последние реальные символы
  Массовые описания External compressors:
    [External compressor:ccm123,ccmx123,ccm125,ccmx125]
    mem = 276
    packcmd   = {compressor} c $$arcdatafile$$.tmp $$arcpackedfile$$.tmp
    unpackcmd = {compressor} d $$arcpackedfile$$.tmp $$arcdatafile$$.tmp
    datafile   = $$arcdatafile$$.tmp
    packedfile = $$arcpackedfile$$.tmp
  500 байт на файл - улучшить реализацию opt_reorder, переупорядочивая файлы только внутри группы ge (при -ds=gerpn)
  Unix: ^Break handling

0.40 pre-3 (17.11.2007)

  -md должен изменять только последний алгоритм в каждой цепочке
  распаковка архивов с ftp/http!
    --proxy, --bypass: http://msdn2.microsoft.com/en-US/library/aa383996.aspx ("," заменяется на пробел)
    unix: libcurl, --proxy
  Fixed problem: archiver freezed with -dm9
  Добавлен вывод размеров промежуточных данных в вывод отладочной информации (-di+$, -di+#)
  Реализован более аккуратный индикатор прогресса, ориентированный на последний алгоритм сжатия в цепочке
    было 14% -> 9% на dll100.dll (rep - "quasiwrite")
    external compressors ("quasiwrite")
    отвести 10% для чтения первым алгоритмом - улучшит работу external
    возвращать время сжатия через callback
    чтение - сигнализировать о чтении внутри цикла (проверить на ghc)
    двигался не только вперёд, но и назад (в частности, на ghc -m3)
    неправильно писалось сколько всего упаковано данных (из-за деления на 10)
    a+x: добавить в индикатор прогресса учёт числа уже обработанных файлов (сделает более аккуратным подсчёт в тех ситуациях, когда файлов очень много)
    rep_compress, delta_compress - проверять ошибки вывода
    оптимизировать (удалять уже использованную часть очереди операций, заменяя её на одну пару r+w операций)
    indicatorThread
  Восстановление архива из инета (перекачка заново только сбойных секторов)
    печать списка сбойных частей (типа 0-1023,4096-8191; в общем, в формате http range)
      "arc r archive --original[=url] --save-bad-ranges=file"
    делать "fileOpen original" только один раз
    поддержка rec_sectors==0 (aREC_VERSION="0.40")
    добавлять в восстановленный архив оригинальную recovery record
    индикаторы прогресса scan/add_rr/recovery
    проверять совпадение размеров --original и восстанавливаемого архива
    --original без параметра - найти URL оригинала в files.bbs/descript.ion
    --original?get_url       - выполнить "get_url arcname" для получения URL оригинала
    если не удалось открыть URL - не отчаиваться
  Защита и восстановление архивов (команды 'r/rr', опция '-rr')
    поддержка -rr0% и -rr0 (запоминаются только CRC 4кб-ных секторов)
    -rr0%;4kb  -rr0*64kb
    вывод в виде "28 errors/sectors (56 kbytes)" (то есть везде добавлены объёмы в байтах)
    сохранение CRC recovery секторов в recovery record
  strip.exe больше не нужен
  unix: выводить дополнительную пустую строку в конце работы программы в связи с разницей между
        работой cmd и sh
  condPrintLineLn "k" "All OK"
  rep - консолидированная запись по 4кб

0.40 pre-4 (16.12.2007)

  Добавлен фильтр exe в $iso/$precomp methods в arc.ini
  Исправлены ошибки:
    freearc.addon: %LQA + -sclANSI
    -m5p extract - non-exhaustive patterns in function callback (euphoria)

0.40 (1.1.2008)

  Сжатие: filetype detection!!!
    не используется для файлов, которые в arc.groups занесены в нестандартные группы ($iso, $precomp и т.д.)
    файл типа $jpg будет детектиться как имеющий тип "", поскольку группы $jpg нет в алгоритме сжатия по умолчанию
  GUI!!!
    запросы комментария архива, паролей шифрования/дешифрования, перезаписи файла


0.41:
  обновить доку и перевести её на английский
  aARCHIVE_VERSION = make4byte 0 0 4 1

  -mrep:1200m - выводится "memory used 1gb", а должен "1500mb" - слишком сильное округление!
  -p=... - "=" может быть частью пароля
  TRUE/FALSE - #ifndef
  // - комментарии в листфайлах
  "-m=ppmd:1538m:" - вылет!
  "xxx+tempfile+xxx+tempfile+xxx"
  rep:300m - неправильно *выводится* объём используемой памяти
  GUI
    окно сообщения об ошибке; подокно варнингов
    overwrite dialog - full info about both files
    use processing time for speed/estimated time
    обновлять раз в 0.5 секунды всё, кроме progressBarSetFraction
    bytes - выводить сколько действительно обработано, без прибавления 10% на read
    Background - вроде не работает.
    При нажатии на крестик - сразу закрывается, без вопросов подтверждения.
    checkbox "Close on exit"; "Remaining time", "Estimated endtime"
    объём озу, используемый текущим алгоритмом
    учитывать, что cbytes может отставать от b (индейская хитрость!)
    tips for labels that explore their data
    добавлять в UI_Read/num=0 имя читаемого файла (или завести отдельную очередь),
      что позволит точнее отображать processed files/current file в CUI и GUI
    поддержка -m5p (external compressors)
    Хотелось бы ещё увидеть:
      1. Время
      - сколько осталось до конца.
      - сколько всего времени с момента запуска работает.
      2. Размер архива:
      - текучка
      - примерный в конце упаковки
      3. Имя обрабатываемого файла (можно даже с путём).
      4. Изменение приоритета.
      5. Дополнительные действия после окончания упаковки (Выключить\Перегрузить\Спящий\Ждущий режим\...)
      6. Если цепочка последовательно выполняется, то наверно нужно отдельную статистику отображать...
      хотения по GUI вообще:
      1. Локализация интерфейса (языки) - в ini, txt или т.п. файликах.
      2. Всплывающие подсказки, особенно где настраиваются алгоритмы сжатия (см. meGUI)
    А ещё:
      1. Интерфейс:
      1.1. Добавление файлов как в WinRK, т.е. возможность накидывать, но в FreeArc с возможностью выбора каким методом паковать. Возможно сделать деление файлов на группы - перетаскиванием на иконку или область например txt\binary\..
      1.2. Возможность выбора каким интерфейсом пользоваться, у всех разные предпочтения, кому-то WinRAR подавай и т.п.
      2. Интеграция с Explorer - чтобы была возможность выбора названия пункта в контекстном меню - или при установке или в настройках программы.
  сохранение опций -m -s -ds в архиве
  "-psome password" в arc.ini
  '-ba' -> '-ra': поиск исправных дескрипторов
  Защита и восстановление архивов (команды 'r/rr', опция '-rr')
    если RR нет/сбойная, то загружать её с указанного URL и затем восстанавливать с её помощью
  Ошибки:
    real-time индикатор прогресса при распаковке - 90% от объёма исходных данных
      + 10% от выходных + количество файлов
    русские буквы в пароле, вводимом с клавиатуры/в диалоге?
    getFileInfo: attr=0; это означает, что их невозможно запоминать в архиве
    "-sc": utf-32, bom в unParseFile, распознавание le/be в parseFile, терминал/логфайл
    сбои в rep; unc names
    "arc a a c:* -ep3"; "arc a a -m1 \* -ep3"
    отбор и исключение целых каталогов: Stats, Stats/, Stats/*, Stats\*, -xStats...
      копирование пустых каталогов в/из архива; перенос непустых каталогов в архив (сам каталог не удаляется)
        arc l a dirname dirname/*  =>  не выводит каталог dirname
      FAR: -apdir1 + dir1/dir2/file in filelist (rar-style?)
      TotalCmd: пустые каталоги не копируются в архив
                при переносе в архив остаются пустые каталоги
      исключение из архивации целого каталога работает только в виде "-xhelp/*"
      "dir/" должна архивировать и сам "dir"
  unixify long option names (keep old names for compatibility?)
  External: удаление временных файлов при ^Break
  dict: уменьшить время init (1/15 sec) для небольших файлов?
  -m3x: исключить delta для text/bmp, tor:7:16m:u2 вместо lzma:fast для -m3xt?
  Unix: LZMA multithreading support, MidnightCommander VFS support


0.41a:
  sfx +дока  (желательно без -lstdc++ для уменьшения размера)
    Поддержка exe+lzp+lzma (method chaining) в SFX/Extractor
    sfx: последовательное применение методов через буфер в памяти?
    unicode: работа Extractor/SFX
  Опции в конфигурации методов сжатия:
    jpg=-s-
    m0=-ds
    m5=-s64m
    -s=8m..2g для -m1..m9, mm- $jpg too?
  4gb: http://msdn2.microsoft.com/en-us/library/aa366521.aspx
  ccm in pipe mode


0.41a:
  Encryption: ch - реализовать дешифрование+шифрование при копировании блока в ArcCreate
  скорость чтения при тестировании архива - всего 10мб/с (see Stats/read10mbs) 0.35->0.36, буферизация?
  -m2: 5% запись на диск, 3% ускорение CRC, 10% kadach MF, 7% huffman (-0.3% compression), 10% use repdist for MM detection

0.41a:
  кадач-lazy matching в lzmaFast и tornado
  External:
    создавать свои файлы в уникальных подкаталогах каталога TEMP
    проверка кода возврата of external compressors?
  Encryption:
    -p- - дешифровать (-p-- - оставить как есть) ?
    -p? -hp? - два отд. пароля?
    перенос в начало списка keyfile/пароля при успешной расшифровке
    reuse previous salt values
    выводить предупреждение при наличии в архиве файлов, сжатых с другим паролем
    подбирать numIterations в соответствии с производительностью машины так, чтобы генерация ключа требовала 0.1 сек
  Unix:
    symlinks, file owner/group/permissions, syslog instead of logfile?, SFX, OS signals handling
    SetConsoleTitle (tigetstr/putp), setpriority (PRIO_PROCESS, 0, xxx) or nice (+-xxx)
  Защита и восстановление архивов (команды 'r/rr', опция '-rr')
    разбивать на части с разными периодами
    добавить в сообщения о сбоях в архиве инфу о расположении сбойных данных
    команда 'r' может тестировать архив и печатать список сбойных солид-блоков
    Если есть посекторный CRC в архиве:
      1. Сделайте распаковку архива с пропуском битых солид-блоков.
      2. Сделайте распаковку битых солид-блоков до битого участка.
    Не хватает ручного восстановления по данным, выкачанным --save-bad-ranges
    "--original?" - files/description/ввод с клавиатуры
  Разделение на модули
    Files => Charsets
    cmdline => options
  FAR plugin: smarter Encrypted detection (:s:v), GetDecompressionMem - прилинковать все модули в режиме FREEARC_INFORMATION_ONLY
  "rn" command, --sync=-u -as, -dp*, -si[name[+size]]/-so, -ssc[-], -ssw, -r0
  (Де)архивация миллионов файлов: тред поиска файлов и упаковка по 100к файлов; распаковка по одному DIRBLOCK за раз
    считывать списки файлов для -ac/-d из dirblocks
  Индикатор прогресса
    продвигаться при работе препроцессоров dict/lzp и многошаговых алгоритмов (dict, grzip)
      10%/n для каждого компрессора в списке кроме последнего
    не учитывать каталоги, поскольку они сжимаются мгновенно
    quasiwrite4rep: -50kb read, 250kb quasiwrite
      read -50kb
      write 250kb
      read 0
      write -250kb
      write ....
      read 50kb - before the next read operation
  Использовать словарь до 48/96 мб для -m3/-m4, в зависимости от объёма свободной памяти
     -lc = max(memory required for decompression, FreeMem())
     :mc - увеличивать/уменьшать автоматически при увеличении/ограничении памяти
     ppmd/pmm:o - увеличивать/уменьшать автоматически при увеличении/ограничении памяти
  Увеличить read-ahead buffer для быстрых режимов сжатия (m1/m2/m3?); async write
  -{m3,m4,m5,m6}, -m{3,4,5,6}   -m1=... (a-la 7-zip)
  "arc command/option" to get help on this command/option
  [External compressor:ccm]
    packcmd=thor e{option} ...
    packcmd=ppmonstr {-%option% } ...
    default_options=1
    default_options=o10 m48
    default_options=o10:m48
    Указание объёма памяти для каждого набора опций по умолчанию, что позволит подбирать режим сжатия, подходящий для данного объёма ОЗУ:
      default_options:256m=5
      default_options:384m/128m=6x
    mem=:m*mb
  Открыть сто файлов, затем их все прочитать/записать, затем все закрыть и перейти к след. порции!
    ускорить распаковку множества мелких файлов (добавить отдельный поток, работающий с файлами)
    --crconly 100 files/sec: Compressed 144.557 files. Compression time Total 1414.34 secs
  Стоны юзеров
    поддержка сохранения/восстановления аттрибутов, прав доступа (ОЧЕНЬ ВАЖНО), времени файлов, symbolic links


Основные улучшения в 0.42
  Сжатие
    lpaq/ppmm
    utf8/16 to codepage switching converter (for text and binary files)
    bcj2 (в rep?), disasm
    bcj/bcj2 в REP, устранить причины уменьшения сжатия при его использовании (repeat перекрывает близкую строчку)
    REP: несколько выходных потоков, встроенный bcj/bcj2/disasm
      ? встроить exe-препроцессор в REP (который имеет доступ к истинным адресам команд CALL), что позволит не делать exe-препроцессинг на повторяющихся фрагментах, как это делается сейчас
    bmp compression (CALIC/SLPRICE/JPEG-LS/BMF)
    xml-wrt & Grabowsky tricks in dict
    сегментирование по структуре *.exe, *.doc
    сжимать выход tta/mm логарифмическим кодированием и отдать логарифмы grzip/ppmd/lzma
    автоперебор параметров сжатия (в частности, ppmd order)
    Значительно можно улучшить степень сжатия, если в архиватор заложить механизм распознавания типов файлов.
      Бинарник - значит жмём так-то, веб-страница - значит так, лог - меняем параметры и т.д.
  использовать ICC для компиляции CompressionLib в DLL (http://www.haskell.org/haskellwiki/FFI_cook_book)
  ускорить dict, lzp, добавить свои MF в lzma; dict для бинарных файлов?
  one-file preprocessors: exe, precomp, mm, jpg
  async -m1 mode
  Multi-volume: при выходе записываемых данных за границы размера тома
    1. создать описание солид-блока с имеющимся списком файлов
    2. сформировать и упаковать в озу блок каталога с дескриптором (общая длина - N)
    3. заменить в архиве последние N байт на каталог
    4. открыть новый том и сбросить в него N байт, не поместившиеся в предыдущий
    5. продолжить процесс упаковки
    продумать взаимодействие с записью Recovery Record
    распаковка нескольких томов
  Warnings
    warnings перезаписываются
    убрать пустую строку перед warning'ом, добавить пробелы если есть индикатор прогресса
    построчная запись и номер процесса в логфайле
    после запроса к пользователю не нужно ещё раз переходить на новую строку
    arccomment - тоже неправильный перевод строки
  lzma: fastest, fast, normal, max, ultra; dict:p - выводить на экран в том же виде


Основные улучшения в 0.43
  -u=new.arc, -mt for -m2/-m3
  mm: YFrFb, YC0Cg and so on
  grzip:bwt - увеличить границы словаря до 16 мб, задокументировать
  *.zip и в $compressed, и в $precomp ?  "$precomp $compressed\n*.zip..."
  в [Compression methods]:  x=[9,8,7,6,5,4,3,2,1]
    "-mx - maximum compression available for this amount of memory"
  сбор статистики о файлах с незнакомыми расширениями для выбора алгоритма сжатия
    mmdet для $wav/$bmp
  mmdet: порверять избыточность rle+ari модели вместо чистой order-0?
  Awe: автоматическое переименование разархивируемых файлов, если в текущем
           каталоге уже имеются файлы с таким же названием (ключ -or в rar).
       В 7zip есть возможность создавать т.н. "incremental backup", было бы здорово встроить
           нечто похожее во FreeArc. То есть, новые/обновившиеся файлы пишутся не в "старый" архив,
           а в новый отдельный файл.
  опция "имя выходного архива"
    опция "виртуальные входные архивы" - при 'u' добавляются только файлы, которых в них нет
    учитывать все входные и выходные архивы при исключении из списка архивации самого архива (overwrite_f)
  Rename[Extracted/Existing] / AutoRename[Extracted/Existing][Unicode/Latin1] / Help
  Выводить arccomment при ВСЕХ операциях (включая 'r' и 'cw')
  сделать опцию "расширенные маски" для использования [] в масках файлов
  compressionLimitMemoryUsage и calcMem содержат особые случаи для DICT и прочих алгоритмов,
    что может быть неверно при изменениях в них и при расчёте памяти для распаковки (compressionLimitMemoryUsage freearcGetDecompressionMem)
Обработка ошибок
  все операции с файлами должны содержать "catch registerError"
  (рас)паковщики должны возвращать разумные номера ошибок, а архиватор - всегда проверять их (сейчас ошибки упаковки и распаковки обнаруживаются только по проверке CRC при распаковке!)
  анализировать коды возврата алгоритмов упаковки и распаковки
  правильные коды возврата в rep/dict/lzp/...
  адеквантно отрабатывать обнаружение ошибок CRC
  option "turn warnings into errors" - вылетать при первом же warning
"m1$rgb = " означает отменить последующие строчки "m1$rgb = ..."
compression methods help?
? m2xb: tor:l4:x:h16m:d8m:p2:s - в отличие от -m2b меньше буфер и больше хеш
Защита и восстановление архивов (команды 'r/rr', опция '-rr')
  восстановление непоследовательных сбойных секторов
    sectors/1.5 - ищем меньшее простое число - sectors/4.5 - снова ищем - ...
    1. Определяем, какие из запорченных секторов секторы восстановимы
         с использованием каждой recovery record (не восстанавливать один сектор дважды!)
    2. Восстанавливаем их, попутно корректируя другие recovery records
    3. Вычёркиваем их из списка испорченых и повторяем процесс пока список
       не опустеет или ни один сектор не может быть больше восстановлен
  поиск блоков recovery
  чтение/запись по 256 кб
  разобраться с двойным footer блоком
  огромные архивы - найти более эффективные решения (несколько recovery блоков?)
  ещё лучше продумать вопросы надёжности при сбоях в конце архива
    разбить данные на куски, скажем 3.5 кб recovery sectors + 500 байт CRC секторов + 12 bytes self-descriptor + CRC
    распределить recovery records равномерно по архиву (между солид-блоками)
правильное упорядочение при обновлении архивов (key_func для 'c'/'i')
benchmarking command
разобраться с использованием памяти, уточнить LimitMem, LimitBlockSize (=размеру блока данных) и тому подобные штучки
  limitDict должен ограничивать словарь первого метода и +100 для последующих методов в цепочке..
  делать предварительный тюнинг метода сжатия и определять размер read-ahead кеша
    после составления списка упаковываемых файлов. Собрать в Compress.hs код для тюнинга
    методов сжатия/размера кеша из всех четырёх мест - Cmdline/arcCreate/splitIntoSolidBlocks/createSolivBlock
  если архивируются файлы только одного типа, то убрать из выводимого списка методов сжатия все остальные методы
-s64m должно означать: данные разбиваются на куски 64m и каталоги остаются при них (это сделает невозможным read-ahead?)
Расширения формата архива
  сохранять в каждом служебном блоке (или его дескрипторе?) расстояние до предыдущего служебного блока - это значительно упростит восстановление архивов
  хранить списки Int в формате 0/1/2/4/8, где 0 - нынешний формат с переменной длиной (записывать формат перед самим списком)
  антифайлы и антикаталоги
  доп. атрибуты (unix/win), 3 времени с высокой точностью
  сплит-файлы (в одном солид-блоке один кусок файла, в другом - второй и так далее)
  сплит-солид-блоки (для многотомных архивов)
  дескриптор блока - хранить в начале его длину, это упростит восстановление архивов
     и позволит в будущем расширять его новыми возможностями, в частностями ключом
     для расшифровки/проверки AV самого блока
  имя атрибута (String) + size + general attributes (COPY/OMIT/STOP+PERFILE/ONCE)
     + type (Number/String/Bytes)
     + representation type (0/1/2/4/8 для целых, S для строк, B для битов)
     + default value для COPY атрибутов
FreeArc 0.50 - переработка методов сжатия:
  LZP: два выходных потока, sliding window, caching MF, multiply hashing, 2 entries?
    hash = lohi(word*123456789), где lohi складывает старшую и младшую часть 64-разрядного слова
    старшие биты в хеш-таблице хранят биты хеша чтобы не лезть зря в память при коллизии
    циклический буфер, выводить "словарь" перед данными, обрабатывать по одному мегабайту
    lzp для ppm* - плавное снижение MinLen по мере роста дистанции совпадения
    препроцессинг для ppmd - уменьшить :h?
    h13 => h15 в окончательной программе?
  tempfile:8mb - буферизовать 8mb прежде чем начинать запись на диск
  external:80%
  ppmd:r0 означает фактически солид-блоки в данных ppmd. это надо использовать :)  -s8m?
  dict/lzp: использовать минимум памяти при распаковке
  -m3=-m3r: lzp:h13, dict:p - равномерно распределить используемые символы
  rep:h32m (сейчас только rep:h23)
-m5$iso, -m.nrg.iso=m5$iso, -m.nrg.iso=$iso, -m.nrg.iso=lzma, -m$iso.nrg.iso, -m$iso:disk.iso
  пофайловые препроцессоры втч внешние
  пофайловый препроцессинг позволит включать exe и lib файлы в один солид-блок
  разные solid-настройки для разных типов файлов и уровней сжатия?
Encrypt/Decrypt/Convert from zip Archive
'lt' - list technical
Compressor = String
Pack each file/directory to a separate archive
automatically delete the archive files after succesful extraction
option to wipe files instead of deleting
compression
  -mb для lzp/dict и других препроцессоров
  размер солид-блока должен соответствовать первому алгоритму в цепочке, если это dict или lzp с большим размером блока
    при этом объём требуемой для упаковки/распаковки памяти нужно считать как max, а не sum?
  размер солид-блока должен быть ограничением сверху (<=64mb), а не снизу, как сейчас
joomla, IPB, smf - forumer
для блочных алгоритмов (включая lzp-препроцессинг) полезно выбирать первый блок таким, чтобы он содержал как можно меньше файлов (для ускорения его чтения с диска)
разбиение по подтипам файлов в splitBy (все примеры для солид-блока в 8 мб)
  1. группа действительно должна обозначать номер группы (например, *hs - все в одной группе $$haskell)
  2. если группа имеет как минимум 2 мб - пустить её отдельным солид-блоком
  3. если группа больше - разбить её на солид-блоки ~6 mb, сгруппировав каталоги как можно более высокого уровня
  4. при чтении архива сортировать солид-группы по имени первого файла в каждой из них
read_file: "чтение" файла, упакованного фейковым методом - нужно для обновления таких архивов
вместо распаковки файла читать его с диска если файлы считаются одинаковыми (при -u, например), тем самым сэкономив время на распаковке
tor: 101..104  EOB/ari  huf/3 таблицы чтобы не терять скорости при +=10
Неподтвердившиеся проблемы:
  -m2p -ms - неправильно определяется чистое время сжатия (и распаковки?)
  почему-то архивы на 1-2 кб больше, чем packed data+packed dir
  ошибка CRC при распаковке - никаких сообщений!

